# Copyright (c) 2019 Lightricks. All rights reserved.
# Created by Noam Freeman.

import xml.etree.ElementTree as ET
import argparse
import collections
import os
import glob

import github_message as message

TESTS_SIGNATURE = "generated_by_comment_test_failures_script"

FailingTest = collections.namedtuple('FailingTest', 'klass name failure_message')

TestReport = collections.namedtuple('TestReport', 'num_of_test failing_tests')


######################
# xml report parsing #
######################

def is_test_failing(test_case_xml):
    return any(child.tag == 'failure' for child in test_case_xml)


def get_test_cases(report_xml):
    return (child for child in report_xml if child.tag == "testcase")


def get_test_name(test_xml):
    return test_xml.attrib["name"]


def get_test_class(test_xml):
    return test_xml.attrib["classname"]


def get_failure_stack(test_xml):
    return [child for child in test_xml if child.tag == "failure"][0]


def get_failure_message(test_xml):
    return get_failure_stack(test_xml).text.splitlines()[0]


def get_test_cases_from_file(junit_xml_path):
    tree = ET.parse(junit_xml_path)
    root = tree.getroot()
    tests = get_test_cases(root)
    return tests


def num_of_tests(junit_xml_path):
    tests_xml_objects = get_test_cases_from_file(junit_xml_path)
    return sum(True for test in tests_xml_objects)


def get_failing_tests_xmls_from_file(junit_xml_path):
    tests_xml_objects = get_test_cases_from_file(junit_xml_path)
    failures = filter(is_test_failing, tests_xml_objects)
    return failures


def create_failing_test(failure_xml):
    klass = get_test_class(failure_xml)
    name = get_test_name(failure_xml)
    reason = get_failure_message(failure_xml)
    return FailingTest(klass=klass, name=name, failure_message=reason)


############
# Markdown #
############

def hidden_html_tag(metadata):
    return f"<p align='right' metadata='{metadata}'></p>\n"


def markdown_table(failing_tests):
    return markdown_test_header() + "\n".join(map(markdown_failing_test, failing_tests))


def markdown_test_header():
    return "| Class | Name | Reason |\n|---|---|---|\n"


def markdown_failing_test(failing_test):
    return markdown_table_separator + \
           markdown_table_separator.join(list(failing_test)) + \
           markdown_table_separator


def details_tag(summary, details):
    return f"<details><summary>{summary}</summary><p>\n\n{details}</p></details>"


markdown_table_separator = " | "
markdown_new_paragraph = "\n\n"

####################
# Module Detection #
####################

module_marker_file = "build.gradle"


def get_immediate_subdirectories(a_dir):
    return next(os.walk(a_dir))[1]


def all_modules(root_dir):
    return {subdir for subdir in get_immediate_subdirectories(root_dir)
            if os.path.isfile(os.path.join(root_dir, subdir, module_marker_file))}


def is_in_module(file, module_name):
    # we assume the file is in the form of "./module/build/..."
    return file.split(os.path.sep)[1] == module_name


def module_of_file(file_path, root_dir):
    all_mods = all_modules(root_dir)
    dir_gen = (dir for dir in file_path.split(os.path.sep) if dir in all_mods)
    return next(dir_gen, None)


def does_module_have_tests(module_path):
    return os.path.exists(os.path.join(module_path, "src", "androidTest")) or \
           os.path.exists(os.path.join(module_path, "src", "test"))


#############################
# Github Comment Formatting #
#############################

def failure_details(results):
    if results.failing_tests:
        return details_tag("Details", markdown_table(results.failing_tests))
    return ""


def emoji_for_result(results):
    if results.failing_tests:
        return ":x:"
    elif results.num_of_test:
        return ":white_check_mark:"
    else:
        return ":warning:"


def test_status_message(results):
    if results.failing_tests:
        return f"{len(results.failing_tests)} out of {results.num_of_test} failed."
    elif results.num_of_test:
        return f"All {results.num_of_test} tests passed."
    else:
        return "No tests have run."


def test_results_comment(modules_test_results):
    res = ""
    for module, result in modules_test_results.items():
        if does_module_have_tests(module):
            emoji = emoji_for_result(result)
            status = test_status_message(result)
            details = failure_details(result)
            res += f"<tr><td> {emoji} {module.capitalize()}: {status} {details}</td></tr>\n"
    return res


def build_status_comment(modules_test_results):
    comment_header = """
## Lightricks CI status
    
<table>
    """

    comment_footer = """
</table>
    
<p align="right" ${commentSignature()}>
Generated by the Lightricks android jenkins team :hammer:
</p>
    """

    return comment_header + test_results_comment(modules_test_results) + comment_footer


########
# Main #
########

def test_report(module_path):
    unittests_results_paths = glob.glob(os.path.join(module_path, "**", "test-results", "**", "*.xml"),
                                        recursive=True)
    connected_tests_results_paths = glob.glob(os.path.join(module_path, "**", "build", "*Test-results", "**", "*.xml"),
                                              recursive=True)
    test_results_paths = unittests_results_paths + connected_tests_results_paths

    failures = []
    test_count = 0
    for test_result in test_results_paths:
        test_count += num_of_tests(test_result)
        failures.extend(get_failing_tests_xmls_from_file(test_result))

    failing_tests = [create_failing_test(failure) for failure in failures]
    return TestReport(test_count, failing_tests)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    # legacy invocation
    parser.add_argument('paths', metavar="test-results", type=str, nargs='*',
                        help='paths of the test result files')

    # new invocation
    parser.add_argument('workspace_dir')

    args = parser.parse_args()
    workspace = args.workspace_dir

    if args.paths:
        # legacy invocation.
        workspace = os.getcwd()

    modules = all_modules(workspace)
    modules_result = {
        module: test_report(os.path.join(workspace, module))
        for module in modules
    }

    tests_signature = hidden_html_tag(TESTS_SIGNATURE)
    message.post_comment_on_current_pr(tests_signature +
                                       build_status_comment(modules_result), tests_signature)
